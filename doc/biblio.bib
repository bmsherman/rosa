%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for Eva Darulova at 2014-03-25 13:44:01 +0100 


%% Saved with string encoding Unicode (UTF-8) 



@article{Westbrook2013,
	Author = {Edwin M. Westbrook and Swarat Chaudhuri},
	Date-Added = {2014-03-25 12:43:59 +0000},
	Date-Modified = {2014-03-25 12:43:59 +0000},
	Journal = {CoRR},
	Keywords = {approximate computing, semantics, modular},
	Title = {A {S}emantics for {A}pproximate {P}rogram {T}ransformations},
	Volume = {abs/1304.5531},
	Year = {2013},
	Abstract = {An approximate program transformation is a transformation that can change the semantics of a program within a specified empirical error bound. Such transformations have wide applications: they can decrease computation time, power consumption, and memory usage, and can, in some cases, allow implementations of incomputable operations. Correctness proofs of approximate program transformations are by definition quantitative. Unfortunately, unlike with standard program transformations, there is as of yet no modular way to prove correctness of an approximate transformation itself. Error bounds must be proved for each transformed program individually, and must be re-proved each time a program is modified or a different set of approximations are applied. In this paper, we give a semantics that enables quantitative reasoning about a large class of approximate program transformations in a local, composable way. Our semantics is based on a notion of distance between programs that defines what it means for an approximate transformation to be correct up to an error bound. The key insight is that distances between programs cannot in general be formulated in terms of metric spaces and real numbers. Instead, our semantics admits natural notions of distance for each type construct; for example, numbers are used as distances for numerical data, functions are used as distances for functional data, an polymorphic lambda-terms are used as distances for polymorphic data. We then show how our semantics applies to two example approximations: replacing reals with floating-point numbers, and loop perforation.}}

@inproceedings{Majumdar2009,
	Author = {Majumdar, Rupak and Saha, Indranil},
	Booktitle = {RTSS},
	Date-Added = {2014-03-25 09:46:10 +0000},
	Date-Modified = {2014-03-25 09:46:10 +0000},
	Keywords = {symbolic execution, robustness, continuity},
	Title = {Symbolic {R}obustness {A}nalysis},
	Year = {2009},
	Abstract = {A key feature of control systems is robustness, the property that small perturbations in the system inputs cause only small changes in its outputs. Robustness is key to designing systems that work under uncertain or imprecise environments. While continuous control design algorithms can explicitly incorporate robustness as a design goal, it is not clear if robustness is maintained at the software implementation level of the controller: two ``close'' inputs can execute very different code paths which may potentially produce vastly different outputs.We present an algorithm and a tool to characterize the robustness of a control software implementation. Our algorithm is based on symbolic execution and non-linear optimization, and computes the maximum difference in program outputs over all program paths when a program input is perturbed. As a by-product, our algorithm generates a set of test vectors which demonstrate the worst-case deviations in outputs for small deviations in inputs. We have implemented our approach on top of the Splat test generation tool and we describe an evaluation of our implementation on two examples of automotive control code.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/RTSS.2009.17}}

@inproceedings{Chaudhuri2011,
	Author = {Chaudhuri, Swarat and Gulwani, Sumit and Lublinerman, Roberto and Navidpour, Sara},
	Booktitle = {ESEC/FSE},
	Date-Added = {2014-03-25 09:45:04 +0000},
	Date-Modified = {2014-03-25 09:45:04 +0000},
	Keywords = {continuity, lipschitz, robustness},
	Title = {Proving {P}rograms {R}obust},
	Year = {2011},
	Abstract = {Requires that the program is continuous, i.e. technique verifies that one, the program is continuous using a previous technique and then shows that each control flow path computes a function that is linear in the values, and the magnitude is bounded by K (Lipschitz constant).


We present a program analysis for verifying quantitative robustness properties of programs, stated generally as: "If the inputs of a program are perturbed by an arbitrary amount epsilon, then its outputs change at most by (K . epsilon), where K can depend on the size of the input but not its value." Robustness properties generalize the analytic notion of continuity---e.g., while the function ex is continuous, it is not robust. Our problem is to verify the robustness of a function P that is coded as an imperative program, and can use diverse data types and features such as branches and loops.

Our approach to the problem soundly decomposes it into two subproblems: (a) verifying that the smallest possible perturbations to the inputs of P do not change the corresponding outputs significantly, even if control now flows along a different control path; and (b) verifying the robustness of the computation along each control-flow path of P. To solve the former subproblem, we build on an existing method for verifying that a program encodes a continuous function [5]. The latter is solved using a static analysis that bounds the magnitude of the slope of any function computed by a control flow path of P. The outcome is a sound program analysis for robustness that uses proof obligations which do not refer to epsilon-changes and can often be fully automated using off-the-shelf SMT-solvers.

We identify three application domains for our analysis. First, our analysis can be used to guarantee the predictable execution of embedded control software, whose inputs come from physical sources and can suffer from error and uncertainty. A guarantee of robustness ensures that the system does not react disproportionately to such uncertainty. Second, our analysis is directly applicable to approximate computation, and can be used to provide foundations for a recently-proposed program approximation scheme called {loop perforation}. A third application is in database privacy: proofs of robustness of queries are essential to differential privacy, the most popular notion of privacy for statistical databases.
},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2025113.2025131},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2025113.2025131}}
